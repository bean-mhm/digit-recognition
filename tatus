[1mdiff --git a/digit-recognition/src/app.hpp b/digit-recognition/src/app.hpp[m
[1mindex bd0738d..eabf8de 100644[m
[1m--- a/digit-recognition/src/app.hpp[m
[1m+++ b/digit-recognition/src/app.hpp[m
[36m@@ -26,7 +26,7 @@[m [mnamespace digitrec[m
 [m
     private:[m
         static constexpr uint32_t seed = 14124;[m
[31m-        static inline const auto activation_fn = neural::tanh<float>;[m
[32m+[m[32m        static inline const auto activation_fn = neural::relu<float>;[m
         static inline const auto activation_deriv = neural::tanh_deriv<float>;[m
 [m
         std::mt19937 rng;[m
[1mdiff --git a/digit-recognition/src/neural.hpp b/digit-recognition/src/neural.hpp[m
[1mindex 4247ca8..1fd1080 100644[m
[1m--- a/digit-recognition/src/neural.hpp[m
[1m+++ b/digit-recognition/src/neural.hpp[m
[36m@@ -30,12 +30,10 @@[m [mnamespace neural[m
         return exp_fn((T)(-.5) * a * a) * inv_sqrt_2pi / standard_deviation;[m
     }[m
 [m
[31m-    template<typename T>[m
[32m+[m[32m    template<typename T, T(*max_fn)(const T&, const T&) = std::max<T>>[m
     T relu(T v)[m
     {[m
[31m-        if (v < (T)0)[m
[31m-            return (T)0;[m
[31m-        return v;[m
[32m+[m[32m        return max_fn((T)0, v);[m
     }[m
 [m
     template<typename T>[m
[36m@@ -46,6 +44,26 @@[m [mnamespace neural[m
         return (T)1;[m
     }[m
 [m
[32m+[m[32m    template<[m
[32m+[m[32m        typename T,[m
[32m+[m[32m        T fac_for_negatives,[m
[32m+[m[32m        T(*max_fn)(const T&, const T&) = std::max<T>[m
[32m+[m[32m    >[m
[32m+[m[32m        requires(fac_for_negatives >= (T)0)[m
[32m+[m[32m    T leaky_relu(T v)[m
[32m+[m[32m    {[m
[32m+[m[32m        return max_fn(v * fac_for_negatives, v);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    template<typename T, T fac_for_negatives>[m
[32m+[m[32m        requires(fac_for_negatives >= (T)0)[m
[32m+[m[32m    T leaky_relu_deriv(T v)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (v < (T)0)[m
[32m+[m[32m            return fac_for_negatives;[m
[32m+[m[32m        return (T)1;[m
[32m+[m[32m    }[m
[32m+[m
     template<typename T, T(*tanh_fn)(T) = std::tanh>[m
     T tanh(T v)[m
     {[m
